// Generated by Haxe 4.2.1
#include <hxcpp.h>

#ifndef INCLUDED_Document
#include <Document.h>
#endif
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_markdown_AutolinkSyntax
#include <markdown/AutolinkSyntax.h>
#endif
#ifndef INCLUDED_markdown_AutolinkSyntaxWithoutBrackets
#include <markdown/AutolinkSyntaxWithoutBrackets.h>
#endif
#ifndef INCLUDED_markdown_CodeSyntax
#include <markdown/CodeSyntax.h>
#endif
#ifndef INCLUDED_markdown_ImgSyntax
#include <markdown/ImgSyntax.h>
#endif
#ifndef INCLUDED_markdown_InlineParser
#include <markdown/InlineParser.h>
#endif
#ifndef INCLUDED_markdown_InlineSyntax
#include <markdown/InlineSyntax.h>
#endif
#ifndef INCLUDED_markdown_LinkSyntax
#include <markdown/LinkSyntax.h>
#endif
#ifndef INCLUDED_markdown_Node
#include <markdown/Node.h>
#endif
#ifndef INCLUDED_markdown_TagState
#include <markdown/TagState.h>
#endif
#ifndef INCLUDED_markdown_TagSyntax
#include <markdown/TagSyntax.h>
#endif
#ifndef INCLUDED_markdown_TextNode
#include <markdown/TextNode.h>
#endif
#ifndef INCLUDED_markdown_TextSyntax
#include <markdown/TextSyntax.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_e6c5d6498b3597f9_12_new,"markdown.InlineParser","new",0x48a4c989,"markdown.InlineParser.new","markdown/InlineParser.hx",12,0xf7baa326)
HX_LOCAL_STACK_FRAME(_hx_pos_e6c5d6498b3597f9_94_parse,"markdown.InlineParser","parse",0x76b5e59c,"markdown.InlineParser.parse","markdown/InlineParser.hx",94,0xf7baa326)
HX_LOCAL_STACK_FRAME(_hx_pos_e6c5d6498b3597f9_132_writeText,"markdown.InlineParser","writeText",0xc36f7f15,"markdown.InlineParser.writeText","markdown/InlineParser.hx",132,0xf7baa326)
HX_LOCAL_STACK_FRAME(_hx_pos_e6c5d6498b3597f9_138_writeTextRange,"markdown.InlineParser","writeTextRange",0x99cfca68,"markdown.InlineParser.writeTextRange","markdown/InlineParser.hx",138,0xf7baa326)
HX_LOCAL_STACK_FRAME(_hx_pos_e6c5d6498b3597f9_154_createText,"markdown.InlineParser","createText",0xfb4bfbc0,"markdown.InlineParser.createText","markdown/InlineParser.hx",154,0xf7baa326)
HX_LOCAL_STACK_FRAME(_hx_pos_e6c5d6498b3597f9_158_addNode,"markdown.InlineParser","addNode",0x97768e6c,"markdown.InlineParser.addNode","markdown/InlineParser.hx",158,0xf7baa326)
HX_LOCAL_STACK_FRAME(_hx_pos_e6c5d6498b3597f9_166_get_currentSource,"markdown.InlineParser","get_currentSource",0xeafd8c34,"markdown.InlineParser.get_currentSource","markdown/InlineParser.hx",166,0xf7baa326)
HX_LOCAL_STACK_FRAME(_hx_pos_e6c5d6498b3597f9_171_get_isDone,"markdown.InlineParser","get_isDone",0xec20934c,"markdown.InlineParser.get_isDone","markdown/InlineParser.hx",171,0xf7baa326)
HX_LOCAL_STACK_FRAME(_hx_pos_e6c5d6498b3597f9_174_advanceBy,"markdown.InlineParser","advanceBy",0x3e42a4e2,"markdown.InlineParser.advanceBy","markdown/InlineParser.hx",174,0xf7baa326)
HX_LOCAL_STACK_FRAME(_hx_pos_e6c5d6498b3597f9_177_consume,"markdown.InlineParser","consume",0x2b09bb65,"markdown.InlineParser.consume","markdown/InlineParser.hx",177,0xf7baa326)
HX_LOCAL_STACK_FRAME(_hx_pos_e6c5d6498b3597f9_182_unescape,"markdown.InlineParser","unescape",0xb44ba4d1,"markdown.InlineParser.unescape","markdown/InlineParser.hx",182,0xf7baa326)
HX_LOCAL_STACK_FRAME(_hx_pos_e6c5d6498b3597f9_13_boot,"markdown.InlineParser","boot",0x3fa48ee9,"markdown.InlineParser.boot","markdown/InlineParser.hx",13,0xf7baa326)
namespace markdown{

void InlineParser_obj::__construct(::String source, ::Document document){
            	HX_GC_STACKFRAME(&_hx_pos_e6c5d6498b3597f9_12_new)
HXLINE(  70)		this->start = 0;
HXLINE(  67)		this->pos = 0;
HXLINE(  75)		this->source = source;
HXLINE(  76)		this->document = document;
HXLINE(  77)		this->stack = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  80)		if (::hx::IsNotNull( document->inlineSyntaxes )) {
HXLINE(  81)			this->syntaxes = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  82)			{
HXLINE(  82)				int _g = 0;
HXDLIN(  82)				::Array< ::Dynamic> _g1 = document->inlineSyntaxes;
HXDLIN(  82)				while((_g < _g1->length)){
HXLINE(  82)					 ::markdown::InlineSyntax syntax = _g1->__get(_g).StaticCast<  ::markdown::InlineSyntax >();
HXDLIN(  82)					_g = (_g + 1);
HXLINE(  83)					this->syntaxes->push(syntax);
            				}
            			}
HXLINE(  84)			{
HXLINE(  84)				int _g2 = 0;
HXDLIN(  84)				::Array< ::Dynamic> _g3 = ::markdown::InlineParser_obj::defaultSyntaxes;
HXDLIN(  84)				while((_g2 < _g3->length)){
HXLINE(  84)					 ::markdown::InlineSyntax syntax = _g3->__get(_g2).StaticCast<  ::markdown::InlineSyntax >();
HXDLIN(  84)					_g2 = (_g2 + 1);
HXLINE(  85)					this->syntaxes->push(syntax);
            				}
            			}
            		}
            		else {
HXLINE(  87)			this->syntaxes = ::markdown::InlineParser_obj::defaultSyntaxes;
            		}
HXLINE(  91)		::Array< ::Dynamic> _hx_tmp = this->syntaxes;
HXDLIN(  91)		_hx_tmp->insert(1, ::markdown::LinkSyntax_obj::__alloc( HX_CTX ,document->linkResolver));
            	}

Dynamic InlineParser_obj::__CreateEmpty() { return new InlineParser_obj; }

void *InlineParser_obj::_hx_vtable = 0;

Dynamic InlineParser_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< InlineParser_obj > _hx_result = new InlineParser_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool InlineParser_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0a59ece7;
}

::Array< ::Dynamic> InlineParser_obj::parse(){
            	HX_GC_STACKFRAME(&_hx_pos_e6c5d6498b3597f9_94_parse)
HXLINE(  96)		::Array< ::Dynamic> _hx_tmp = this->stack;
HXDLIN(  96)		_hx_tmp->push( ::markdown::TagState_obj::__alloc( HX_CTX ,0,0,null()));
HXLINE(  98)		while(!(this->get_isDone())){
HXLINE(  99)			bool matched = false;
HXLINE( 103)			{
HXLINE( 103)				int _g = 1;
HXDLIN( 103)				int _g1 = this->stack->length;
HXDLIN( 103)				while((_g < _g1)){
HXLINE( 103)					_g = (_g + 1);
HXDLIN( 103)					int i = (_g - 1);
HXLINE( 104)					if (this->stack->__get((this->stack->length - i)).StaticCast<  ::markdown::TagState >()->tryMatch(::hx::ObjectPtr<OBJ_>(this))) {
HXLINE( 105)						matched = true;
HXLINE( 106)						goto _hx_goto_4;
            					}
            				}
            				_hx_goto_4:;
            			}
HXLINE( 110)			if (matched) {
HXLINE( 111)				continue;
            			}
HXLINE( 114)			{
HXLINE( 114)				int _g2 = 0;
HXDLIN( 114)				::Array< ::Dynamic> _g3 = this->syntaxes;
HXDLIN( 114)				while((_g2 < _g3->length)){
HXLINE( 114)					 ::markdown::InlineSyntax syntax = _g3->__get(_g2).StaticCast<  ::markdown::InlineSyntax >();
HXDLIN( 114)					_g2 = (_g2 + 1);
HXLINE( 115)					if (syntax->tryMatch(::hx::ObjectPtr<OBJ_>(this))) {
HXLINE( 116)						matched = true;
HXLINE( 117)						goto _hx_goto_5;
            					}
            				}
            				_hx_goto_5:;
            			}
HXLINE( 121)			if (matched) {
HXLINE( 122)				continue;
            			}
HXLINE( 125)			this->advanceBy(1);
            		}
HXLINE( 129)		return this->stack->__get(0).StaticCast<  ::markdown::TagState >()->close(::hx::ObjectPtr<OBJ_>(this));
            	}


HX_DEFINE_DYNAMIC_FUNC0(InlineParser_obj,parse,return )

void InlineParser_obj::writeText(){
            	HX_STACKFRAME(&_hx_pos_e6c5d6498b3597f9_132_writeText)
HXLINE( 133)		this->writeTextRange(this->start,this->pos);
HXLINE( 134)		this->start = this->pos;
            	}


HX_DEFINE_DYNAMIC_FUNC0(InlineParser_obj,writeText,(void))

void InlineParser_obj::writeTextRange(int start,int end){
            	HX_STACKFRAME(&_hx_pos_e6c5d6498b3597f9_138_writeTextRange)
HXDLIN( 138)		if ((end > start)) {
HXLINE( 139)			::String text = this->source.substring(start,end);
HXLINE( 140)			::Array< ::Dynamic> nodes = this->stack->__get((this->stack->length - 1)).StaticCast<  ::markdown::TagState >()->children;
HXLINE( 143)			bool _hx_tmp;
HXDLIN( 143)			if ((nodes->length > 0)) {
HXLINE( 143)				_hx_tmp = ::Std_obj::isOfType(nodes->__get((nodes->length - 1)),( ( ::Dynamic)(::hx::ClassOf< ::markdown::TextNode >()) ));
            			}
            			else {
HXLINE( 143)				_hx_tmp = false;
            			}
HXDLIN( 143)			if (_hx_tmp) {
HXLINE( 144)				 ::markdown::TextNode lastNode = ( ( ::markdown::TextNode)(nodes->__get((nodes->length - 1))) );
HXLINE( 145)				 ::markdown::TextNode newNode = this->createText(((HX_("",00,00,00,00) + lastNode->text) + text));
HXLINE( 146)				nodes[(nodes->length - 1)] = newNode;
            			}
            			else {
HXLINE( 148)				nodes->push(this->createText(text));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(InlineParser_obj,writeTextRange,(void))

 ::markdown::TextNode InlineParser_obj::createText(::String text){
            	HX_GC_STACKFRAME(&_hx_pos_e6c5d6498b3597f9_154_createText)
HXDLIN( 154)		return  ::markdown::TextNode_obj::__alloc( HX_CTX ,this->unescape(text));
            	}


HX_DEFINE_DYNAMIC_FUNC1(InlineParser_obj,createText,return )

void InlineParser_obj::addNode(::Dynamic node){
            	HX_STACKFRAME(&_hx_pos_e6c5d6498b3597f9_158_addNode)
HXDLIN( 158)		this->stack->__get((this->stack->length - 1)).StaticCast<  ::markdown::TagState >()->children->push(node);
            	}


HX_DEFINE_DYNAMIC_FUNC1(InlineParser_obj,addNode,(void))

::String InlineParser_obj::get_currentSource(){
            	HX_STACKFRAME(&_hx_pos_e6c5d6498b3597f9_166_get_currentSource)
HXDLIN( 166)		return this->source.substring(this->pos,this->source.length);
            	}


HX_DEFINE_DYNAMIC_FUNC0(InlineParser_obj,get_currentSource,return )

bool InlineParser_obj::get_isDone(){
            	HX_STACKFRAME(&_hx_pos_e6c5d6498b3597f9_171_get_isDone)
HXDLIN( 171)		return (this->pos == this->source.length);
            	}


HX_DEFINE_DYNAMIC_FUNC0(InlineParser_obj,get_isDone,return )

void InlineParser_obj::advanceBy(int length){
            	HX_STACKFRAME(&_hx_pos_e6c5d6498b3597f9_174_advanceBy)
HXDLIN( 174)		 ::markdown::InlineParser _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 174)		_hx_tmp->pos = (_hx_tmp->pos + length);
            	}


HX_DEFINE_DYNAMIC_FUNC1(InlineParser_obj,advanceBy,(void))

void InlineParser_obj::consume(int length){
            	HX_STACKFRAME(&_hx_pos_e6c5d6498b3597f9_177_consume)
HXLINE( 178)		 ::markdown::InlineParser _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 178)		_hx_tmp->pos = (_hx_tmp->pos + length);
HXLINE( 179)		this->start = this->pos;
            	}


HX_DEFINE_DYNAMIC_FUNC1(InlineParser_obj,consume,(void))

::String InlineParser_obj::unescape(::String text){
            	HX_GC_STACKFRAME(&_hx_pos_e6c5d6498b3597f9_182_unescape)
HXLINE( 183)		text =  ::EReg_obj::__alloc( HX_CTX ,HX_("\\\\([\\\\`*_{}\\[\\]()#+-.!])",9f,d0,5b,7b),HX_("g",67,00,00,00))->replace(text,HX_("$1",8d,1f,00,00));
HXLINE( 184)		text = ::StringTools_obj::replace(text,HX_("\t",09,00,00,00),HX_("    ",00,38,3f,15));
HXLINE( 185)		return text;
            	}


HX_DEFINE_DYNAMIC_FUNC1(InlineParser_obj,unescape,return )

::Array< ::Dynamic> InlineParser_obj::defaultSyntaxes;


::hx::ObjectPtr< InlineParser_obj > InlineParser_obj::__new(::String source, ::Document document) {
	::hx::ObjectPtr< InlineParser_obj > __this = new InlineParser_obj();
	__this->__construct(source,document);
	return __this;
}

::hx::ObjectPtr< InlineParser_obj > InlineParser_obj::__alloc(::hx::Ctx *_hx_ctx,::String source, ::Document document) {
	InlineParser_obj *__this = (InlineParser_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(InlineParser_obj), true, "markdown.InlineParser"));
	*(void **)__this = InlineParser_obj::_hx_vtable;
	__this->__construct(source,document);
	return __this;
}

InlineParser_obj::InlineParser_obj()
{
}

void InlineParser_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(InlineParser);
	HX_MARK_MEMBER_NAME(source,"source");
	HX_MARK_MEMBER_NAME(document,"document");
	HX_MARK_MEMBER_NAME(syntaxes,"syntaxes");
	HX_MARK_MEMBER_NAME(pos,"pos");
	HX_MARK_MEMBER_NAME(start,"start");
	HX_MARK_MEMBER_NAME(stack,"stack");
	HX_MARK_END_CLASS();
}

void InlineParser_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(source,"source");
	HX_VISIT_MEMBER_NAME(document,"document");
	HX_VISIT_MEMBER_NAME(syntaxes,"syntaxes");
	HX_VISIT_MEMBER_NAME(pos,"pos");
	HX_VISIT_MEMBER_NAME(start,"start");
	HX_VISIT_MEMBER_NAME(stack,"stack");
}

::hx::Val InlineParser_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"pos") ) { return ::hx::Val( pos ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"start") ) { return ::hx::Val( start ); }
		if (HX_FIELD_EQ(inName,"stack") ) { return ::hx::Val( stack ); }
		if (HX_FIELD_EQ(inName,"parse") ) { return ::hx::Val( parse_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"source") ) { return ::hx::Val( source ); }
		if (HX_FIELD_EQ(inName,"isDone") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_isDone() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"addNode") ) { return ::hx::Val( addNode_dyn() ); }
		if (HX_FIELD_EQ(inName,"consume") ) { return ::hx::Val( consume_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"document") ) { return ::hx::Val( document ); }
		if (HX_FIELD_EQ(inName,"syntaxes") ) { return ::hx::Val( syntaxes ); }
		if (HX_FIELD_EQ(inName,"unescape") ) { return ::hx::Val( unescape_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"writeText") ) { return ::hx::Val( writeText_dyn() ); }
		if (HX_FIELD_EQ(inName,"advanceBy") ) { return ::hx::Val( advanceBy_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"createText") ) { return ::hx::Val( createText_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_isDone") ) { return ::hx::Val( get_isDone_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"currentSource") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_currentSource() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"writeTextRange") ) { return ::hx::Val( writeTextRange_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"get_currentSource") ) { return ::hx::Val( get_currentSource_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool InlineParser_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 15:
		if (HX_FIELD_EQ(inName,"defaultSyntaxes") ) { outValue = ( defaultSyntaxes ); return true; }
	}
	return false;
}

::hx::Val InlineParser_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"pos") ) { pos=inValue.Cast< int >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"start") ) { start=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stack") ) { stack=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"source") ) { source=inValue.Cast< ::String >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"document") ) { document=inValue.Cast<  ::Document >(); return inValue; }
		if (HX_FIELD_EQ(inName,"syntaxes") ) { syntaxes=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool InlineParser_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 15:
		if (HX_FIELD_EQ(inName,"defaultSyntaxes") ) { defaultSyntaxes=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
	}
	return false;
}

void InlineParser_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("source",db,b0,31,32));
	outFields->push(HX_("document",1b,ef,12,9b));
	outFields->push(HX_("syntaxes",91,79,84,5f));
	outFields->push(HX_("pos",94,5d,55,00));
	outFields->push(HX_("start",62,74,0b,84));
	outFields->push(HX_("stack",48,67,0b,84));
	outFields->push(HX_("currentSource",f4,31,8e,15));
	outFields->push(HX_("isDone",8c,b5,d4,5f));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo InlineParser_obj_sMemberStorageInfo[] = {
	{::hx::fsString,(int)offsetof(InlineParser_obj,source),HX_("source",db,b0,31,32)},
	{::hx::fsObject /*  ::Document */ ,(int)offsetof(InlineParser_obj,document),HX_("document",1b,ef,12,9b)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(InlineParser_obj,syntaxes),HX_("syntaxes",91,79,84,5f)},
	{::hx::fsInt,(int)offsetof(InlineParser_obj,pos),HX_("pos",94,5d,55,00)},
	{::hx::fsInt,(int)offsetof(InlineParser_obj,start),HX_("start",62,74,0b,84)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(InlineParser_obj,stack),HX_("stack",48,67,0b,84)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo InlineParser_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(void *) &InlineParser_obj::defaultSyntaxes,HX_("defaultSyntaxes",72,37,92,88)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String InlineParser_obj_sMemberFields[] = {
	HX_("source",db,b0,31,32),
	HX_("document",1b,ef,12,9b),
	HX_("syntaxes",91,79,84,5f),
	HX_("pos",94,5d,55,00),
	HX_("start",62,74,0b,84),
	HX_("stack",48,67,0b,84),
	HX_("parse",33,90,55,bd),
	HX_("writeText",2c,c1,ad,55),
	HX_("writeTextRange",f1,94,d7,e6),
	HX_("createText",c9,8d,87,5f),
	HX_("addNode",c3,4c,47,85),
	HX_("get_currentSource",4b,3d,fe,1b),
	HX_("get_isDone",55,25,5c,50),
	HX_("advanceBy",f9,e6,80,d0),
	HX_("consume",bc,79,da,18),
	HX_("unescape",9a,72,21,dd),
	::String(null()) };

static void InlineParser_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(InlineParser_obj::defaultSyntaxes,"defaultSyntaxes");
};

#ifdef HXCPP_VISIT_ALLOCS
static void InlineParser_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(InlineParser_obj::defaultSyntaxes,"defaultSyntaxes");
};

#endif

::hx::Class InlineParser_obj::__mClass;

static ::String InlineParser_obj_sStaticFields[] = {
	HX_("defaultSyntaxes",72,37,92,88),
	::String(null())
};

void InlineParser_obj::__register()
{
	InlineParser_obj _hx_dummy;
	InlineParser_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("markdown.InlineParser",17,51,35,b8);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &InlineParser_obj::__GetStatic;
	__mClass->mSetStaticField = &InlineParser_obj::__SetStatic;
	__mClass->mMarkFunc = InlineParser_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(InlineParser_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(InlineParser_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< InlineParser_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = InlineParser_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = InlineParser_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = InlineParser_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void InlineParser_obj::__boot()
{
{
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		::Array< ::Dynamic> _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_e6c5d6498b3597f9_13_boot)
HXLINE(  24)			 ::markdown::AutolinkSyntaxWithoutBrackets _hx_tmp =  ::markdown::AutolinkSyntaxWithoutBrackets_obj::__alloc( HX_CTX );
HXLINE(  25)			 ::markdown::TextSyntax _hx_tmp1 =  ::markdown::TextSyntax_obj::__alloc( HX_CTX ,HX_(" {2,}\n",02,61,e3,be),HX_("<br />\n",e7,06,fa,a6));
HXLINE(  26)			 ::markdown::TextSyntax _hx_tmp2 =  ::markdown::TextSyntax_obj::__alloc( HX_CTX ,HX_("\\s*[A-Za-z0-9]+",82,ca,6c,01),null());
HXLINE(  28)			 ::markdown::AutolinkSyntax _hx_tmp3 =  ::markdown::AutolinkSyntax_obj::__alloc( HX_CTX );
HXLINE(  29)			 ::markdown::LinkSyntax _hx_tmp4 =  ::markdown::LinkSyntax_obj::__alloc( HX_CTX ,null());
HXLINE(  30)			 ::markdown::ImgSyntax _hx_tmp5 =  ::markdown::ImgSyntax_obj::__alloc( HX_CTX ,null());
HXLINE(  32)			 ::markdown::TextSyntax _hx_tmp6 =  ::markdown::TextSyntax_obj::__alloc( HX_CTX ,HX_(" \\* ",f2,c7,6c,15),null());
HXLINE(  34)			 ::markdown::TextSyntax _hx_tmp7 =  ::markdown::TextSyntax_obj::__alloc( HX_CTX ,HX_(" _ ",01,9b,18,00),null());
HXLINE(  37)			 ::markdown::TextSyntax _hx_tmp8 =  ::markdown::TextSyntax_obj::__alloc( HX_CTX ,HX_("&[#a-zA-Z0-9]*;",e0,ca,38,8a),null());
HXLINE(  39)			 ::markdown::TextSyntax _hx_tmp9 =  ::markdown::TextSyntax_obj::__alloc( HX_CTX ,HX_("&",26,00,00,00),HX_("&amp;",dd,d4,aa,21));
HXLINE(  41)			 ::markdown::TextSyntax _hx_tmp10 =  ::markdown::TextSyntax_obj::__alloc( HX_CTX ,HX_("<(?:!--[ ]*|/)?\\w+.*?>",d6,96,f0,eb),null());
HXLINE(  43)			 ::markdown::TextSyntax _hx_tmp11 =  ::markdown::TextSyntax_obj::__alloc( HX_CTX ,HX_("<",3c,00,00,00),HX_("&lt;",4d,74,70,19));
HXLINE(  45)			 ::markdown::TagSyntax _hx_tmp12 =  ::markdown::TagSyntax_obj::__alloc( HX_CTX ,HX_("\\*\\*",1c,d0,ef,3c),HX_("strong",57,b6,34,11),null());
HXLINE(  47)			 ::markdown::TagSyntax _hx_tmp13 =  ::markdown::TagSyntax_obj::__alloc( HX_CTX ,HX_("__",20,53,00,00),HX_("strong",57,b6,34,11),null());
HXLINE(  49)			 ::markdown::TagSyntax _hx_tmp14 =  ::markdown::TagSyntax_obj::__alloc( HX_CTX ,HX_("\\*",4e,50,00,00),HX_("em",68,58,00,00),null());
HXLINE(  51)			 ::markdown::TagSyntax _hx_tmp15 =  ::markdown::TagSyntax_obj::__alloc( HX_CTX ,HX_("\\b_",19,25,46,00),HX_("em",68,58,00,00),HX_("_\\b",a5,66,48,00));
HXLINE(  53)			 ::markdown::CodeSyntax _hx_tmp16 =  ::markdown::CodeSyntax_obj::__alloc( HX_CTX ,HX_("``\\s?((?:.|\\n)*?)\\s?``",5a,1c,bf,91));
HXLINE(  13)			return ::Array_obj< ::Dynamic>::__new(18)->init(0,_hx_tmp)->init(1,_hx_tmp1)->init(2,_hx_tmp2)->init(3,_hx_tmp3)->init(4,_hx_tmp4)->init(5,_hx_tmp5)->init(6,_hx_tmp6)->init(7,_hx_tmp7)->init(8,_hx_tmp8)->init(9,_hx_tmp9)->init(10,_hx_tmp10)->init(11,_hx_tmp11)->init(12,_hx_tmp12)->init(13,_hx_tmp13)->init(14,_hx_tmp14)->init(15,_hx_tmp15)->init(16,_hx_tmp16)->init(17, ::markdown::CodeSyntax_obj::__alloc( HX_CTX ,HX_("`([^`]*)`",99,e1,26,ec)));
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_e6c5d6498b3597f9_13_boot)
HXDLIN(  13)		defaultSyntaxes = ( (::Array< ::Dynamic>)( ::Dynamic(new _hx_Closure_0())()) );
            	}
}

} // end namespace markdown
