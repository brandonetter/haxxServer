// Generated by Haxe 4.2.1
#include <hxcpp.h>

#ifndef INCLUDED_Document
#include <Document.h>
#endif
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_markdown_BlockParser
#include <markdown/BlockParser.h>
#endif
#ifndef INCLUDED_markdown_BlockSyntax
#include <markdown/BlockSyntax.h>
#endif
#ifndef INCLUDED_markdown_ElementNode
#include <markdown/ElementNode.h>
#endif
#ifndef INCLUDED_markdown_Node
#include <markdown/Node.h>
#endif
#ifndef INCLUDED_markdown_TableSyntax
#include <markdown/TableSyntax.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_3713a098cc383f7c_655_new,"markdown.TableSyntax","new",0x480b66e4,"markdown.TableSyntax.new","markdown/BlockParser.hx",655,0x037f5eb2)
HX_LOCAL_STACK_FRAME(_hx_pos_3713a098cc383f7c_659_get_pattern,"markdown.TableSyntax","get_pattern",0x262920eb,"markdown.TableSyntax.get_pattern","markdown/BlockParser.hx",659,0x037f5eb2)
HX_LOCAL_STACK_FRAME(_hx_pos_3713a098cc383f7c_663_get_canEndBlock,"markdown.TableSyntax","get_canEndBlock",0xe284cbbd,"markdown.TableSyntax.get_canEndBlock","markdown/BlockParser.hx",663,0x037f5eb2)
HX_LOCAL_STACK_FRAME(_hx_pos_3713a098cc383f7c_694_parse,"markdown.TableSyntax","parse",0x1302cfb7,"markdown.TableSyntax.parse","markdown/BlockParser.hx",694,0x037f5eb2)
HX_LOCAL_STACK_FRAME(_hx_pos_3713a098cc383f7c_666_parse,"markdown.TableSyntax","parse",0x1302cfb7,"markdown.TableSyntax.parse","markdown/BlockParser.hx",666,0x037f5eb2)
HX_LOCAL_STACK_FRAME(_hx_pos_3713a098cc383f7c_684_parse,"markdown.TableSyntax","parse",0x1302cfb7,"markdown.TableSyntax.parse","markdown/BlockParser.hx",684,0x037f5eb2)
static const int _hx_array_data_b1d564f2_8[] = {
	(int)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_3713a098cc383f7c_709_parse,"markdown.TableSyntax","parse",0x1302cfb7,"markdown.TableSyntax.parse","markdown/BlockParser.hx",709,0x037f5eb2)
static const int _hx_array_data_b1d564f2_10[] = {
	(int)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_3713a098cc383f7c_651_boot,"markdown.TableSyntax","boot",0xba07a12e,"markdown.TableSyntax.boot","markdown/BlockParser.hx",651,0x037f5eb2)
HX_LOCAL_STACK_FRAME(_hx_pos_3713a098cc383f7c_652_boot,"markdown.TableSyntax","boot",0xba07a12e,"markdown.TableSyntax.boot","markdown/BlockParser.hx",652,0x037f5eb2)
namespace markdown{

void TableSyntax_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_3713a098cc383f7c_655_new)
HXDLIN( 655)		super::__construct();
            	}

Dynamic TableSyntax_obj::__CreateEmpty() { return new TableSyntax_obj; }

void *TableSyntax_obj::_hx_vtable = 0;

Dynamic TableSyntax_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TableSyntax_obj > _hx_result = new TableSyntax_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool TableSyntax_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x19853322) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x19853322;
	} else {
		return inClassId==(int)0x41d975bd;
	}
}

 ::EReg TableSyntax_obj::get_pattern(){
            	HX_STACKFRAME(&_hx_pos_3713a098cc383f7c_659_get_pattern)
HXDLIN( 659)		return ::markdown::TableSyntax_obj::TABLE_PATTERN;
            	}


bool TableSyntax_obj::get_canEndBlock(){
            	HX_STACKFRAME(&_hx_pos_3713a098cc383f7c_663_get_canEndBlock)
HXDLIN( 663)		return false;
            	}


::Dynamic TableSyntax_obj::parse( ::markdown::BlockParser parser){
            		HX_BEGIN_LOCAL_FUNC_S4(::hx::LocalFunc,_hx_Closure_1, ::markdown::BlockParser,parser,::Array< int >,index,::Array< ::String >,aligns,::Array< ::Dynamic>,heads) HXARGC(1)
            		::String _hx_run( ::EReg e){
            			HX_GC_STACKFRAME(&_hx_pos_3713a098cc383f7c_694_parse)
HXLINE( 695)			::String text = ::StringTools_obj::trim(e->matched(2));
HXLINE( 696)			 ::markdown::ElementNode cell =  ::markdown::ElementNode_obj::__alloc( HX_CTX ,HX_("th",74,65,00,00),parser->document->parseInline(text));
HXLINE( 697)			if ((aligns->__get(index->__get(0)) != HX_("left",07,08,b0,47))) {
HXLINE( 698)				cell->attributes->set(HX_("align",c5,56,91,21),aligns->__get(index->__get(0)));
            			}
HXLINE( 699)			heads->push(cell);
HXLINE( 700)			::Array< int > index1 = index;
HXDLIN( 700)			int _hx_tmp = 0;
HXDLIN( 700)			index1[_hx_tmp] = (index1->__get(_hx_tmp) + 1);
HXLINE( 701)			return HX_("",00,00,00,00);
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_GC_STACKFRAME(&_hx_pos_3713a098cc383f7c_666_parse)
HXLINE( 667)		::Array< ::String > lines = ::Array_obj< ::String >::__new(0);
HXLINE( 669)		while(true){
HXLINE( 669)			bool _hx_tmp;
HXDLIN( 669)			if ((parser->pos < parser->lines->length)) {
HXLINE( 669)				_hx_tmp = parser->matches(::markdown::TableSyntax_obj::TABLE_PATTERN);
            			}
            			else {
HXLINE( 669)				_hx_tmp = false;
            			}
HXDLIN( 669)			if (!(_hx_tmp)) {
HXLINE( 669)				goto _hx_goto_3;
            			}
HXLINE( 670)			lines->push(parser->lines->__get(parser->pos));
HXLINE( 671)			parser->advance();
            		}
            		_hx_goto_3:;
HXLINE( 674)		::Array< ::Dynamic> heads = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 675)		::Array< ::Dynamic> rows = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 678)		::String headLine = ( (::String)(lines->shift()) );
HXLINE( 679)		::String alignLine = ( (::String)(lines->shift()) );
HXLINE( 682)		::Array< ::String > aligns = ::Array_obj< ::String >::__new(0);
HXLINE( 683)		if (::hx::IsNotNull( alignLine )) {
            			HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0,::Array< ::String >,aligns) HXARGC(1)
            			::String _hx_run( ::EReg e){
            				HX_STACKFRAME(&_hx_pos_3713a098cc383f7c_684_parse)
HXLINE( 685)				::String text = e->matched(2);
HXLINE( 686)				::String align;
HXDLIN( 686)				if ((text.charAt(0) == HX_(":",3a,00,00,00))) {
HXLINE( 686)					if ((text.charAt((text.length - 1)) == HX_(":",3a,00,00,00))) {
HXLINE( 686)						align = HX_("center",d5,25,db,05);
            					}
            					else {
HXLINE( 686)						align = HX_("left",07,08,b0,47);
            					}
            				}
            				else {
HXLINE( 686)					if ((text.charAt((text.length - 1)) == HX_(":",3a,00,00,00))) {
HXLINE( 686)						align = HX_("right",dc,0b,64,e9);
            					}
            					else {
HXLINE( 686)						align = HX_("left",07,08,b0,47);
            					}
            				}
HXLINE( 687)				aligns->push(align);
HXLINE( 688)				return HX_("",00,00,00,00);
            			}
            			HX_END_LOCAL_FUNC1(return)

HXLINE( 684)			::markdown::TableSyntax_obj::CELL_PATTERN->map(alignLine, ::Dynamic(new _hx_Closure_0(aligns)));
            		}
HXLINE( 693)		::Array< int > index = ::Array_obj< int >::fromData( _hx_array_data_b1d564f2_8,1);
HXLINE( 694)		::markdown::TableSyntax_obj::CELL_PATTERN->map(headLine, ::Dynamic(new _hx_Closure_1(parser,index,aligns,heads)));
HXLINE( 704)		{
HXLINE( 704)			int _g = 0;
HXDLIN( 704)			while((_g < lines->length)){
            				HX_BEGIN_LOCAL_FUNC_S4(::hx::LocalFunc,_hx_Closure_2,::Array< ::Dynamic>,cols, ::markdown::BlockParser,parser,::Array< int >,index,::Array< ::String >,aligns) HXARGC(1)
            				::String _hx_run( ::EReg e){
            					HX_GC_STACKFRAME(&_hx_pos_3713a098cc383f7c_709_parse)
HXLINE( 710)					::String text = ::StringTools_obj::trim(e->matched(2));
HXLINE( 711)					 ::markdown::ElementNode cell =  ::markdown::ElementNode_obj::__alloc( HX_CTX ,HX_("td",70,65,00,00),parser->document->parseInline(text));
HXLINE( 712)					if ((aligns->__get(index->__get(0)) != HX_("left",07,08,b0,47))) {
HXLINE( 713)						cell->attributes->set(HX_("align",c5,56,91,21),aligns->__get(index->__get(0)));
            					}
HXLINE( 714)					cols->push(cell);
HXLINE( 715)					::Array< int > index1 = index;
HXDLIN( 715)					int _hx_tmp = 0;
HXDLIN( 715)					index1[_hx_tmp] = (index1->__get(_hx_tmp) + 1);
HXLINE( 716)					return HX_("",00,00,00,00);
            				}
            				HX_END_LOCAL_FUNC1(return)

HXLINE( 704)				::String line = lines->__get(_g);
HXDLIN( 704)				_g = (_g + 1);
HXLINE( 705)				::Array< ::Dynamic> cols = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 706)				rows->push( ::markdown::ElementNode_obj::__alloc( HX_CTX ,HX_("tr",7e,65,00,00),cols));
HXLINE( 708)				::Array< int > index = ::Array_obj< int >::fromData( _hx_array_data_b1d564f2_10,1);
HXLINE( 709)				::markdown::TableSyntax_obj::CELL_PATTERN->map(line, ::Dynamic(new _hx_Closure_2(cols,parser,index,aligns)));
            			}
            		}
HXLINE( 720)		 ::markdown::ElementNode _hx_tmp =  ::markdown::ElementNode_obj::__alloc( HX_CTX ,HX_("thead",94,73,86,0f),heads);
HXDLIN( 720)		return  ::markdown::ElementNode_obj::__alloc( HX_CTX ,HX_("table",0e,b8,e3,0a),::Array_obj< ::Dynamic>::__new(2)->init(0,_hx_tmp)->init(1, ::markdown::ElementNode_obj::__alloc( HX_CTX ,HX_("tbody",16,c5,96,0b),rows)));
            	}


 ::EReg TableSyntax_obj::TABLE_PATTERN;

 ::EReg TableSyntax_obj::CELL_PATTERN;


::hx::ObjectPtr< TableSyntax_obj > TableSyntax_obj::__new() {
	::hx::ObjectPtr< TableSyntax_obj > __this = new TableSyntax_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< TableSyntax_obj > TableSyntax_obj::__alloc(::hx::Ctx *_hx_ctx) {
	TableSyntax_obj *__this = (TableSyntax_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(TableSyntax_obj), false, "markdown.TableSyntax"));
	*(void **)__this = TableSyntax_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

TableSyntax_obj::TableSyntax_obj()
{
}

::hx::Val TableSyntax_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"parse") ) { return ::hx::Val( parse_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"get_pattern") ) { return ::hx::Val( get_pattern_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_canEndBlock") ) { return ::hx::Val( get_canEndBlock_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool TableSyntax_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"CELL_PATTERN") ) { outValue = ( CELL_PATTERN ); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"TABLE_PATTERN") ) { outValue = ( TABLE_PATTERN ); return true; }
	}
	return false;
}

bool TableSyntax_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"CELL_PATTERN") ) { CELL_PATTERN=ioValue.Cast<  ::EReg >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"TABLE_PATTERN") ) { TABLE_PATTERN=ioValue.Cast<  ::EReg >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *TableSyntax_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo TableSyntax_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::EReg */ ,(void *) &TableSyntax_obj::TABLE_PATTERN,HX_("TABLE_PATTERN",9f,c1,4b,8a)},
	{::hx::fsObject /*  ::EReg */ ,(void *) &TableSyntax_obj::CELL_PATTERN,HX_("CELL_PATTERN",53,8f,d6,71)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String TableSyntax_obj_sMemberFields[] = {
	HX_("get_pattern",67,66,71,97),
	HX_("get_canEndBlock",39,7f,83,a3),
	HX_("parse",33,90,55,bd),
	::String(null()) };

static void TableSyntax_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(TableSyntax_obj::TABLE_PATTERN,"TABLE_PATTERN");
	HX_MARK_MEMBER_NAME(TableSyntax_obj::CELL_PATTERN,"CELL_PATTERN");
};

#ifdef HXCPP_VISIT_ALLOCS
static void TableSyntax_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(TableSyntax_obj::TABLE_PATTERN,"TABLE_PATTERN");
	HX_VISIT_MEMBER_NAME(TableSyntax_obj::CELL_PATTERN,"CELL_PATTERN");
};

#endif

::hx::Class TableSyntax_obj::__mClass;

static ::String TableSyntax_obj_sStaticFields[] = {
	HX_("TABLE_PATTERN",9f,c1,4b,8a),
	HX_("CELL_PATTERN",53,8f,d6,71),
	::String(null())
};

void TableSyntax_obj::__register()
{
	TableSyntax_obj _hx_dummy;
	TableSyntax_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("markdown.TableSyntax",f2,64,d5,b1);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &TableSyntax_obj::__GetStatic;
	__mClass->mSetStaticField = &TableSyntax_obj::__SetStatic;
	__mClass->mMarkFunc = TableSyntax_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(TableSyntax_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(TableSyntax_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< TableSyntax_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = TableSyntax_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TableSyntax_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TableSyntax_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void TableSyntax_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_3713a098cc383f7c_651_boot)
HXDLIN( 651)		TABLE_PATTERN =  ::EReg_obj::__alloc( HX_CTX ,HX_("^(.+?:?\\|:?)+(.+)$",5c,7a,0a,3f),HX_("",00,00,00,00));
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_3713a098cc383f7c_652_boot)
HXDLIN( 652)		CELL_PATTERN =  ::EReg_obj::__alloc( HX_CTX ,HX_("(\\|)?([^\\|]+)(\\|)?",50,fa,46,7b),HX_("g",67,00,00,00));
            	}
}

} // end namespace markdown
